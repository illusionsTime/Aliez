## æ’å…¥æ’åº
#### ä¸€ä¸ªç®€å•çš„å®šç†
*ä»»ä½•é€šè¿‡äº¤æ¢ç›¸é‚»å…ƒç´ è¿›è¡Œæ’åºçš„ç®—æ³•å¹³å‡æ—¶é—´å¤æ‚åº¦ä¸ºÎ©(N^2)*

è¯æ˜ï¼šå‡è®¾ä¸€ä¸ªNçš„æ•°ç»„Lï¼Œæˆ‘ä»¬å¯¹Lä¸­`å…·æœ‰æ€§è´¨i<jä½†æ˜¯A[i]>A[j]çš„åºå¶`ç§°ä¸º*é€†åº*,Lä¸­é€†åºçš„æ•°é‡å°±æ˜¯æ’å…¥æ’åºéœ€è¦äº¤æ¢å…ƒç´ çš„æ•°é‡ï¼Œæ¯ä¸€æ¬¡äº¤æ¢èƒ½å¤Ÿæ¶ˆç­ä¸€ç»„é€†åº

ä¸ºäº†å¾—åˆ°Lä¸­å¹³å‡é€†åºçš„æ•°é‡ã€‚æˆ‘ä»¬è€ƒè™‘ä»–çš„ååºè¡¨Lr,å¯¹äºLLråˆå¹¶çš„æ•°ç»„ï¼Œä»»æ„ä¸¤ä¸ªæ•°çš„åºå¶(x,y)y>xæ°æ°æ˜¯LLrä¸­çš„ä¸€ä¸ªï¼Œè¯¥åºå¶å¯¹åº”ä¸€ä¸ªé€†åºã€‚åœ¨è¿™ä¸¤ä¸ªè¡¨ä¸­è¿™æ ·çš„åºå¶æ€»ä¸ªæ•°ä¸º0+1+...+N-1=N(N-1)/2,å› æ­¤å¹³å‡è¡¨æœ‰è¯¥é‡çš„ä¸€åŠå³ä¸ºN(N-1)/4

åˆå§‹çš„å¹³å‡é€†åºæ•°ä¸ºN(N-1)/4=Î©(N^2),è€Œæ¯æ¬¡äº¤æ¢å‡å°‘ä¸€ä¸ªé€†åºï¼Œå› æ­¤éœ€è¦Î©(N^2)æ¬¡äº¤æ¢ï¼Œæ•…çš„è¯ã€‚

#### è§£é‡Š 
æ’å…¥æ’åºå¯¹äºä¸€ä¸ªä½ç½®åœ¨Pçš„å…ƒç´ ï¼ŒPä¹‹å‰çš„å…ƒç´ ä¸ºå·²æ’åºçŠ¶æ€ï¼Œæˆ‘ä»¬å°†På…ƒç´ ä¸ä¹‹å‰çš„å…ƒç´ è¿›è¡Œæ¯”è¾ƒæ‰¾åˆ°ä½ç½®ï¼Œå°†è¯¥ä½ç½®ä¹‹åçš„å…ƒç´ éƒ½å³ç§»ä¸€ä½ï¼Œå°†På…ƒç´ ç½®äºè¯¥ä½ç½®ï¼Œä¿è¯ç§»åŠ¨ä¹‹åPä¹‹å‰çš„å…ƒç´ ä¸ºæœ‰åºï¼Œä¹Ÿå°±æ˜¯è¯´æ’å…¥æ’åºåŒæ ·ç”±N-1è¶Ÿæ’åºç»„æˆï¼Œæ˜¯ç¨³å®šæ’åºã€‚

#### ä¾‹ç¨‹
```go
func InsertSort(A []int) {
	var tmp, j int
	N := len(A)
	for i := 0; i < N; i++ {
		tmp = A[i]
		for j = i; j > 0 && A[j-1] > tmp; j-- {
			A[j] = A[j-1]
		}
		A[j] = tmp
	}
}
```

## å¸Œå°”æ’åºï¼ˆç¼©å°å¢é‡æ’åºï¼‰
å¸Œå°”æ’åºé€šè¿‡ä¸€ä¸ªå¢é‡åºåˆ—ï¼Œåœ¨é€‚ç”¨å¢é‡Hkçš„ä¸€è¶Ÿæ’åºåï¼Œå¯¹äºæ¯ä¸€ä¸ªiæˆ‘ä»¬æœ‰A[i]<=A[i+Hk];æ‰€æœ‰ç›¸éš”hkçš„å…ƒç´ éƒ½è¢«æ’åºï¼Œæ­¤æ—¶ç§°æ–‡ä»¶æ˜¯hk-sortedã€‚  
å¸Œå°”æ‹çš„ä¸€ä¸ªé‡è¦æ€§è´¨æ˜¯ï¼Œä¸€ä¸ªhk-æ’åºçš„æ–‡ä»¶ä¿æŒä»–çš„hk-æ’åºæ€§ã€‚hkæ’åºçš„ä¸€èˆ¬åšæ³•æ˜¯ï¼Œå¯¹äºhkï¼Œhk+1ï¼Œ....,N-1ä¸­çš„æ¯ä¸€ä¸ªä½ç½®iï¼ŒæŠŠå…¶ä¸­çš„å…ƒç´ æ”¾åˆ°i,i-hk,i-2hkï¼Œï¼Œä¸­é—´çš„æ­£ç¡®ä½ç½®ä¸Šã€‚*ä¸€è¶Ÿhk-æ’åºçš„ä½œç”¨å°±æ˜¯å¯¹hkä¸ªç‹¬ç«‹çš„å­æ•°ç»„æ‰§è¡Œä¸€æ¬¡æ’å…¥æ’åº*


```go
func ShellSort(num []int) {
	var tmp int
	var i, j int
	N := len(num)
	for Increment := N / 2; Increment > 0; Increment = Increment / 2 {
		for i = Increment; i < N; i++ {
			tmp = num[i]
			for j = i; j >= Increment; j -= Increment {
				if tmp < num[j-Increment] {
					num[j] = num[j-Increment]
				} else {
					break
				}
			}
			num[j] = tmp
		}
	}
}

```


## å¿«é€Ÿæ’åº
å¦‚åŒå½’å¹¶æ’åºä¸€æ ·ï¼Œå¿«æ’ä¹Ÿæ˜¯ä¸€ç§åˆ†æ²»é€’å½’ç®—æ³•ï¼Œå°†æ•°ç»„è¿›è¡Œå¿«é€Ÿæ’åºçš„åŸºæœ¬ç®—æ³•ç”±ä»¥ä¸‹å‡ æ­¥ç»„æˆï¼š

1. å¦‚æœSä¸­å…ƒç´ ä¸ªæ•°ä¸º0æˆ–è€…1ï¼Œè¿”å›S
2. å–Sä¸­ä»»æ„å…ƒç´ vï¼Œç§°ä¹‹ä¸ºæ¢çº½å…ƒï¼ˆpivotï¼‰
3. å°†Sä¸­çš„å…¶ä½™å…ƒç´ åˆ†æˆä¸¤ä¸ªä¸ç›¸äº¤çš„é›†åˆï¼ŒS1={xâˆˆS-{v}|x<=v}å’ŒS2={xâˆˆS-{v}|x>=v}
4. è¿”å›{quicksortï¼ˆS1ï¼‰åï¼Œç»§éšvï¼Œç»§è€Œquicksort(S2)}ã€‚

#### åˆ†å‰²ç­–ç•¥
é€šè¿‡ä¸¤ä¸ªæŒ‡é’ˆlï¼Œrï¼Œå½“låœ¨rçš„å·¦è¾¹æ—¶ï¼Œæˆ‘ä»¬å°†lå³ç§»ï¼Œç§»è¿‡é‚£äº›å°äºæ¢çº½å…ƒçš„å…ƒç´ ï¼Œå¹¶å°†rå·¦ç§»ï¼Œç§»è¿‡é‚£äº›å¤§äºæ¢çº½å…ƒçš„å…ƒç´ ã€‚
å½“lï¼Œråœæ­¢æ—¶ï¼Œlåªæƒ³ä¸€ä¸ªå¤§å…ƒç´ è€ŒræŒ‡å‘ä¸€ä¸ªå°å…ƒç´ ï¼Œå¦‚æœlåœ¨rçš„å·¦è¾¹ï¼Œé‚£ä¹ˆè¿™ä¸¤ä¸ªå…ƒç´ äº’æ¢ã€‚
åˆ†å‰²çš„æœ€åä¸€æ­¥æ˜¯å°†æ¢çº½å…ƒä¸læŒ‡å‘çš„å…ƒç´ äº’æ¢ã€‚

```go
func QSort(num []int, left, right int) {
	if right > left {
		pivot := partition(num, left, right)
		QSort(num, left, pivot-1)
		QSort(num, pivot+1, right)
	}
}

func partition(list []int, low, high int) int {
	pivot := list[low] //å¯¼è‡´ low ä½ç½®å€¼ä¸ºç©º
	for low < high {
		//highæŒ‡é’ˆå€¼ >= pivot highæŒ‡é’ˆğŸ‘ˆç§»
		for low < high && pivot <= list[high] {
			high--
		}
		//å¡«è¡¥lowä½ç½®ç©ºå€¼
		//highæŒ‡é’ˆå€¼ < pivot highå€¼ ç§»åˆ°lowä½ç½®
		//high ä½ç½®å€¼ç©º
		list[low] = list[high]
		//lowæŒ‡é’ˆå€¼ <= pivot lowæŒ‡é’ˆğŸ‘‰ç§»
		for low < high && pivot >= list[low] {
			low++
		}
		//å¡«è¡¥highä½ç½®ç©ºå€¼
		//lowæŒ‡é’ˆå€¼ > pivot lowå€¼ ç§»åˆ°highä½ç½®
		//lowä½ç½®å€¼ç©º
		list[high] = list[low]
	}
	//pivot å¡«è¡¥ lowä½ç½®çš„ç©ºå€¼
	list[low] = pivot
	return low
}

```

## å †æ’åº 
ä¼˜å…ˆé˜Ÿåˆ—å¯ä»¥ç”¨äºèŠ±è´¹O(NlogN)æ—¶é—´çš„æ’åºã€‚åŸºäºè¯¥æƒ³æ³•çš„æ’åºå«åšå †æ’åºã€‚  
åŸºæœ¬çš„æ€è·¯æ˜¯å»ºç«‹Nä¸ªå…ƒç´ çš„äºŒå‰å †ï¼Œæ­¤æ—¶èŠ±è´¹O(N)æ—¶é—´ã€‚ç„¶åæ‰§è¡ŒNæ¬¡DeleteMinæ“ä½œã€‚æŒ‰ç…§é¡ºåºï¼Œæœ€å°çš„å…ƒç´ å…ˆç¦»å¼€è¯¥å †ã€‚é€šè¿‡å°†è¿™äº›å…ƒç´ è®°å½•åˆ°é¢å¤–æ•°ç»„ï¼Œç„¶ååšä¸€æ¬¡copyå°±å¾—åˆ°äº†Nä¸ªå…ƒç´ çš„æ’åºã€‚ç”±äºæ¯ä¸ªDeleteMinèŠ±è´¹çš„æ—¶é—´æ˜¯O(logN),å› æ­¤æ€»çš„è¿è¡Œæ—¶é—´æ˜¯O(NlogN)

è¿™ä¸ªæ€è·¯æœ‰ä¸ªä¸»è¦é—®é¢˜ï¼Œå®ƒä½¿ç”¨äº†ä¸€ä¸ªé¢å¤–æ•°ç»„ï¼Œä¸€ä¸ªèªæ˜çš„åšæ³•æ˜¯ï¼š  
åœ¨æ¯æ¬¡DeleteMinä¹‹åï¼Œå †ç¼©å°äº†1ï¼Œå› æ­¤ä½äºå †æœ€åçš„å•å…ƒå¯ä»¥ç”¨æ¥å­˜æ”¾åˆšåˆšåˆ å»çš„å…ƒç´ ã€‚
#### ä¾‹ç¨‹
```go
func HeapSort(num []int) {
	var i int
	size := len(num)
	//ä»æœ€æ·±å¤„çˆ¶èŠ‚ç‚¹æ„é€ å †
	for i = size / 2; i >= 0; i-- {
		PercDown(num, i, size)
	}
	for i = size - 1; i > 0; i-- {
		Swap(num[0], num[i])
		PercDown(num, 0, i)
	}
}

func PercDown(num []int, i int, size int) {
	var child int
	var tmp int
	for tmp = num[i]; 2*i+1 < size; i = child {
		child = 2*i + 1 //childæ˜¯å·¦å„¿å­
		//æ‰¾åˆ°æ›´å¤§çš„å„¿å­èŠ‚ç‚¹
		if child != size-1 && num[child+1] > num[child] {
			child++
		}
		//å¦‚æœå½“å‰çˆ¶èŠ‚ç‚¹å°äºå„¿å­èŠ‚ç‚¹ï¼Œäº¤æ¢ä½ç½®
		if tmp < num[child] {
			num[i] = num[child]
		} else {
			break
		}
	}
	num[i] = tmp
}

func Swap(a interface{}, b interface{}) {
	var tmp interface{}
	tmp = a
	a = b
	b = tmp
}
```
#### å¤æ‚åº¦åˆ†æ
*å¯¹Nä¸ªäº’å¼‚é¡¹è¿›è¡Œå †æ’åºï¼Œæ‰€ç”¨çš„æ¯”è¾ƒå¹³å‡æ¬¡æ•°ä¸º2NlogN-O(NlogN)*

è¯æ˜ï¼š  
æ„å»ºå †å¾—é˜¶æ®µå¹³å‡ä½¿ç”¨Oï¼ˆnï¼‰æ¬¡æ¯”è¾ƒï¼Œnä¸ªèŠ‚ç‚¹çš„å®Œå…¨äºŒå‰æ ‘çš„æ·±åº¦ã€Œ$\log(2)N$+1ã€,åˆ™è°ƒæ•´çš„è¿‡ç¨‹è°ƒç”¨ä¸‹æ»¤ä¸€å…±n-1æ¬¡ï¼Œæ€»å…±çš„æ¯”è¾ƒæ¬¡æ•°ä¸è¶…è¿‡
2($\log(2)(N-1)$+$\log(2)(N-2)$+....+$\log(2)N$)<2N($\log(2)N$)  

å› æ­¤è¯´ å †æ’åºåœ¨æœ€åæƒ…å†µä¸‹ï¼Œå…¶æ—¶é—´å¤æ‚åº¦ä¹Ÿä¸ºO(nlogn)

## å½’å¹¶æ’åº

####  è¯¦è§£
å½’å¹¶æ’åºæ˜¯é€’å½’ç®—æ³•çš„ä¸€ä¸ªå¾ˆå¥½çš„å®ä¾‹ï¼Œä»–çš„åŸºæœ¬æ“ä½œæ˜¯åˆå¹¶ä¸¤ä¸ªå·²æ’åºçš„è¡¨ã€‚å› ä¸ºè¿™ä¸¤ä¸ªè¡¨æ˜¯å·²ç»æ’åºçš„ï¼Œæ‰€ä»¥è‹¥å°†è¾“å‡ºæ”¾åˆ°ç¬¬ä¸‰ä¸ªè¡¨ä¸­æ—¶ï¼Œè¯¥ç®—æ³•å¯ä»¥é€šè¿‡å¯¹è¾“å…¥æ•°æ®çš„ä¸€è¶Ÿæ’åºæ¥å®Œæˆã€‚

å¯¹äºä¸€ä¸ªæ•°ç»„ï¼Œå½’å¹¶æ’åºé€’å½’åœ°å°†å‰åŠéƒ¨åˆ†æ•°æ®å’ŒååŠéƒ¨åˆ†æ•°æ®å„è‡ªè¿›è¡Œå½’å¹¶æ’åºï¼Œå¾—åˆ°æ’åºåçš„ä¸¤éƒ¨åˆ†æ•°æ®ï¼Œç„¶åä½¿ç”¨`åˆå¹¶`ç®—æ³•å†å°†ä¸¤éƒ¨åˆ†åˆå¹¶åˆ°ä¸€èµ·ã€‚ä¾‹å¦‚

æœ‰ä¸€ä¸ªæ•°ç»„ [1ã€2ã€23ã€4ã€38ã€15ã€13ã€24],å½’å¹¶æ’åº
1. é¦–å…ˆæ‹†åˆ†å·¦å³æ•°ç»„ï¼Œå°†æ•°ç»„æ‹†åˆ†æˆ[1ã€2ã€23ã€4] [38ã€15ã€13ã€24]
2. é€’å½’çš„å¯¹å·¦å³æ•°ç»„è¿›è¡Œæ’åºï¼Œå¾—åˆ°æ’åºåçš„ä¸¤éƒ¨åˆ†æ•°ç»„
3. ä½¿ç”¨åˆå¹¶ç®—æ³•å°†ä¸¤éƒ¨åˆ†åˆå¹¶åˆ°ä¸€èµ·


åŸºæœ¬çš„åˆå¹¶ç®—æ³•æ˜¯ï¼Œå–è¾“å…¥æ•°ç»„Aï¼ŒBï¼Œè¾“å‡ºæ•°ç»„Cï¼Œä»¥åŠä¸‰ä¸ªè®¡æ•°å™¨Aptrï¼ŒBptrï¼ŒCptrï¼Œä»–ä»¬åˆå§‹ç½®äºæ•°ç»„çš„å¼€å§‹ç«¯ã€‚
æ’åºåçš„æ•°ç»„ä¸º [1ã€2ã€4ã€23]    [13ã€15ã€24ã€38]   [ ã€ ã€ ã€ ã€ ã€ ã€ ã€ ]
              Aptr             Bptr              Cptr

é¦–å…ˆæ¯”è¾ƒåˆå§‹çš„1å’Œ13ï¼Œ1è¢«åŠ å…¥åˆ°Cä¸­,ç„¶åå°†2ä¸13è¿›è¡Œæ¯”è¾ƒ
[1ã€2ã€4ã€23]  [13ã€15ã€24ã€38]   [1ã€ ã€ ã€ ã€ ã€ ã€ ã€ ]
    Aptr        Bptr                Cptr
2è¢«åŠ å…¥åˆ°Cä¸­ï¼Œè¿ç»­è¿›è¡Œæ¯”è¾ƒç›´è‡³Aä¸­å…ƒç´ å…¨éƒ¨åŠ å…¥åˆ°Cä¸­
[1ã€2ã€4ã€23]  [13ã€15ã€24ã€38]   [1ã€2ã€4 ã€13 ã€15 ã€23 ã€ ã€ ]
            Aptr       Bptr                              Cptr
å°†Bä¸­å‰©ä½™å…ƒç´ å…¨éƒ¨copyè¿›å…¥Cä¸­ã€‚

å¯ä»¥çœ‹åˆ°ï¼Œåˆå¹¶ä¸¤ä¸ªè¡¨çš„æ—¶é—´æ˜¾ç„¶æ˜¯çº¿æ€§çš„ï¼Œå› ä¸ºæœ€å¤šè¿›è¡Œäº†N-1æ¬¡æ¯”è¾ƒã€‚å½’å¹¶æ’åºæ˜¯ç»å…¸çš„`åˆ†æ²»`ç­–ç•¥ï¼Œå®ƒæ˜¯å°†é—®é¢˜åˆ†è§£ä¸ºä¸€äº›å°é—®é¢˜ç„¶åé€’å½’æ±‚è§£ï¼Œè€Œæ²»çš„é˜¶æ®µåˆ™å°†
åˆ†çš„é˜¶æ®µå¾—åˆ°çš„è§£è¿›è¡Œåˆå¹¶ã€‚

#### ä¾‹ç¨‹
```go

//å½’å¹¶æ’åº
func MergeSort(A []int) {
	//åˆ†é…é¢å¤–ç©ºé—´
	N := len(A)
	tmp := make([]int, N)
	if tmp != nil {
		MSort(A, tmp, 0, N-1)
	} else {
		errors.New("No space for tmp array!")
	}

}

func MSort(A []int, tmp []int, Left int, Right int) {
	var Center int
	if Left < Right {
		//æ‹†åˆ†å·¦å³æ•°ç»„ é€’å½’è¿›è¡Œæ’åº
		Center = (Left + Right) / 2
		MSort(A, tmp, Left, Center)
		MSort(A, tmp, Center+1, Right)
		//åˆå¹¶å·¦å³æ•°ç»„
		Merge(A, tmp, Left, Center+1, Right)
	}
}

func Merge(A []int, TmpArray []int, Lptr int, Rptr int, REnd int) {
	LEnd := Rptr - 1
	TmpPos := Lptr
	NumElements := REnd - Lptr + 1

	//ä»å¼€å§‹ç«¯è¿›è¡Œæ¯”è¾ƒï¼Œå¹¶éæ”¾å…¥é¢å¤–æ•°ç»„ä¸­
	for Lptr <= LEnd && Rptr <= REnd {
		if A[Lptr] <= A[Rptr] {
			TmpArray[TmpPos] = A[Lptr]
			TmpPos++
			Lptr++
		} else {
			TmpArray[TmpPos] = A[Rptr]
			TmpPos++
			Rptr++
		}
	}
	//å°†å‰©ä½™æ•°ç»„å…ƒç´ è¿›è¡Œå¤åˆ¶å¡«æ»¡é¢å¤–æ•°ç»„
	for Lptr <= LEnd {
		TmpArray[TmpPos] = A[Lptr]
		TmpPos++0
		Lptr++
	}
	//
	for Rptr <= REnd {
		TmpArray[TmpPos] = A[Rptr]
		TmpPos++
		Rptr++
	}

	//
	for i := 0; i < NumElements; i, REnd = i+1, REnd-1 {
		A[REnd] = TmpArray[REnd]
	}
}

```

#### æ—¶é—´å¤æ‚åº¦åˆ†æ

å‡è®¾Næ˜¯2çš„å¹‚ï¼Œè¿™æ ·æˆ‘ä»¬åœ¨é€’å½’æ—¶æ€»èƒ½å°†å®ƒåˆ†è£‚æˆå‡ä¸ºå¶æ•°çš„ä¸¤éƒ¨åˆ†ã€‚
å¯¹äºN=1ï¼Œå½’å¹¶æ’åºæ‰€ç”¨æ—¶é—´æ˜¯å¸¸æ•°ï¼Œå¯¹Nä¸ä¸º1çš„æ•°è¿›è¡Œå½’å¹¶æ’åºï¼Œå…¶ç”¨æ—¶ç­‰äºå®Œæˆä¸¤ä¸ªå¤§å°ä¸ºN/2çš„é€’å½’æ’åºæ‰€ç”¨æ—¶é—´åŠ ä¸Šåˆå¹¶çš„æ—¶é—´ï¼Œç”±æ­¤å¾—å‡º

1. T(1) = 1
2. T(N)=2T(N/2)+N

ä¸€ç§æ–¹æ³•æ˜¯é€šè¿‡*å ç¼©*,è¿™é‡Œæˆ‘ä»¬é‡‡ç”¨é€’å½’å¸¦å…¥
å¯¹2å¼è¿›è¡Œå¸¦å…¥ï¼Œä»¤N=N/2
```                    T(N/2)=2(T(N/4))+N/2 
                    2T(N/2)=2(2(T(N/4))+N/2)  //ä¸¤è¾¹åŒæ—¶ä¹˜2
					       =4T(N/4)+N
```
å¾—åˆ°    
3. T(N)=4T(N/4)+2N
ç»§ç»­å¯¹2å¼è¿›è¡Œè¿­ä»£ ä»¤N=N/4 å¹¶åŒæ—¶ä¹˜4
```
                      4T(N/4)=4(2T(N/8)+N/4)=8T(N/8)+N
				å¸¦å…¥3å¼  å¾—åˆ°T(N)=8T(N/8)+3N
```
ç»§ç»­è¿­ä»£ å¯ä»¥å¾—åˆ°

                `T(N)=2^kT(N/2^k)+k*N`
åˆ©ç”¨k=log N å¯å¾—åˆ°
             `T(N)=NT(1)+N log N=Nlog N+N`
è¿™é‡Œæˆ‘ä»¬æ˜¯åˆ†æN=2^k,å¦‚æœä¸èƒ½åˆ†è§£å¾—åˆ°å¶æ•°æ•°ç»„ï¼Œå…¶å®å¾—åˆ°ç­”æ¡ˆä¹Ÿæ˜¯ä¸€æ ·çš„ï¼Œä¹Ÿå°±æ˜¯è¯´å½’å¹¶æ’åºæ˜¯ä¸€ç§*ç¨³å®šæ’åº*ï¼Œå…¶æ—¶é—´å¤æ‚åº¦ä¸ºO(N logN),ç©ºé—´å¤æ‚åº¦ä¸ºO(N)

#### å®ä¾‹
åˆå¹¶Â kÂ ä¸ªæ’åºé“¾è¡¨ï¼Œè¿”å›åˆå¹¶åçš„æ’åºé“¾è¡¨ã€‚è¯·åˆ†æå’Œæè¿°ç®—æ³•çš„å¤æ‚åº¦ã€‚

ç¤ºä¾‹:

è¾“å…¥:
[
Â  1->4->5,
Â  1->3->4,
Â  2->6
]
è¾“å‡º: 1->1->2->3->4->4->5->6

é¢˜è§£ï¼šé‡‡ç”¨åˆ†æ²»çš„æ€è·¯ å°†ä¸¤ä¸¤é“¾è¡¨è¿›è¡Œåˆå¹¶å¾—åˆ°æœ€ç»ˆçš„æœ‰åºé“¾è¡¨ã€‚
æ—¶é—´å¤æ‚åº¦åˆ†æï¼š å‡è®¾nä¸ºé“¾è¡¨çš„å¹³å‡é•¿åº¦ï¼Œç¬¬ä¸€æ¬¡é€’å½’éœ€è¦åˆå¹¶k/2ä¸ªé“¾è¡¨ï¼Œæ¯ç»„éœ€è¦O(2n)çš„æ—¶é—´ï¼Œç¬¬äºŒæ¬¡éœ€è¦k/4ä¸ªé“¾è¡¨ï¼Œæ¯ç»„è€—æ—¶O(4n),ä¾æ¬¡ç±»æ¨ï¼Œæ€»çš„æ—¶é—´ä»£ä»·ä¸º
âˆ
Î£ (k/2^iâœ–2^iÂ·n)  iä¸ºä»¥2ä¸ºåº•kçš„å¯¹æ•°ï¼Œå°±ç­‰äºO(knÂ·logk)
i=1

ç©ºé—´å¤æ‚åº¦ï¼šé€’å½’ä¼šä½¿ç”¨åˆ°O(logk) ç©ºé—´ä»£ä»·çš„æ ˆç©ºé—´ã€‚

ä»£ç ï¼š
```go

type ListNode struct {
	Val  int
	Next *ListNode
}

func mergeKLists(lists []*ListNode) *ListNode {
	r := len(lists)
	return msortList(lists, 0, r-1)
}

func msortList(lists []*ListNode, l int, r int) *ListNode {
	if l > r {
		return nil
	}
	if l == r {
		return lists[l]
	}
	mid := (l + r) >> 1
	return mergeTwoLists(msortList(lists, l, mid), msortList(lists, mid+1, r))
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
	prevhead := new(ListNode)
	prevhead.Val = -1
	prev := prevhead
	for l1 != nil && l2 != nil {
		if l1.Val <= l2.Val {
			prev.Next = l1
			l1 = l1.Next
		} else {
			prev.Next = l2
			l2 = l2.Next
		}
		prev = prev.Next
	}

	if l1 == nil && l2 != nil {
		prev.Next = l2
	} else {
		prev.Next = l1
	}
	return prevhead.Next
}

```
